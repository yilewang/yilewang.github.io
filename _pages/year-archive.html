---
layout: archive
permalink: /year-archive/
title: "Blog posts"
author_profile: true
redirect_from:
  - /wordpress/blog-posts/
---

{% include base_path %}

<div style="margin-bottom: 2em;">
  <h3>Filter by Tags</h3>
  <p id="tag-filters">
    {% assign all_tags = site.posts | map: 'tags' | flatten | compact | uniq | sort %}
    {% if all_tags.size > 0 %}
      {% for tag in all_tags %}
        {% if tag != nil and tag != '' %}
          <button class="btn btn--primary tag-filter-btn" data-tag="{{ tag | slugify }}" style="margin: 0.25em;">{{ tag }}</button>
        {% endif %}
      {% endfor %}
    {% endif %}
    <button class="btn btn--primary tag-filter-btn" id="clear-filters" style="margin: 0.25em;">Clear All</button>
  </p>
  <p id="active-filters" style="margin-top: 1em; font-style: italic; color: #666;"></p>
</div>

<div id="posts-container">
{% capture written_year %}'None'{% endcapture %}
{% for post in site.posts %}
  {% capture year %}{{ post.date | date: '%Y' }}{% endcapture %}
  {% if year != written_year %}
    <h2 id="{{ year | slugify }}" class="archive__subtitle year-header" data-year="{{ year }}">{{ year }}</h2>
    {% capture written_year %}{{ year }}{% endcapture %}
  {% endif %}
  {% if post.tags.size > 0 %}
    {% capture post_tags %}{% for tag in post.tags %}{{ tag | slugify }} {% endfor %}{% endcapture %}
    <div class="post-item" data-tags="{{ post_tags | strip }}">
  {% else %}
    <div class="post-item" data-tags="">
  {% endif %}
    {% include archive-single.html %}
  </div>
{% endfor %}
</div>

<script>
(function() {
  'use strict';
  
  function init() {
    const tagButtons = document.querySelectorAll('.tag-filter-btn');
    const clearButton = document.getElementById('clear-filters');
    const activeFiltersEl = document.getElementById('active-filters');
    const postItems = document.querySelectorAll('.post-item');
    const yearHeaders = document.querySelectorAll('.year-header');
    let selectedTags = new Set();

    function updateActiveFilters() {
      if (!activeFiltersEl) return;
      if (selectedTags.size === 0) {
        activeFiltersEl.textContent = '';
      } else {
        activeFiltersEl.textContent = 'Active filters: ' + Array.from(selectedTags).join(', ');
      }
    }

    function filterPosts() {
      if (!postItems || postItems.length === 0) return;
      
      postItems.forEach(function(post) {
        const tagsAttr = post.getAttribute('data-tags');
        if (!tagsAttr || tagsAttr.trim() === '') {
          post.style.display = selectedTags.size === 0 ? '' : 'none';
          return;
        }
        
        const postTags = tagsAttr.trim().split(/\s+/).filter(function(t) { return t.length > 0; });
        const hasAllTags = selectedTags.size === 0 || Array.from(selectedTags).every(function(tag) {
          return postTags.indexOf(tag) !== -1;
        });
        
        if (hasAllTags) {
          post.style.display = '';
        } else {
          post.style.display = 'none';
        }
      });

      // Hide year headers if no posts are visible in that year
      if (yearHeaders && yearHeaders.length > 0) {
        yearHeaders.forEach(function(header) {
          const year = header.getAttribute('data-year');
          let hasVisiblePosts = false;
          
          // Find the next sibling post items after this header
          let current = header.nextElementSibling;
          while (current) {
            if (current.classList && current.classList.contains('post-item')) {
              if (current.style.display !== 'none') {
                hasVisiblePosts = true;
                break;
              }
            } else if (current.classList && current.classList.contains('year-header')) {
              break;
            }
            current = current.nextElementSibling;
          }
          
          if (!hasVisiblePosts && selectedTags.size > 0) {
            header.style.display = 'none';
          } else {
            header.style.display = '';
          }
        });
      }
    }

    if (tagButtons && tagButtons.length > 0) {
      tagButtons.forEach(function(btn) {
        if (btn.id !== 'clear-filters') {
          btn.addEventListener('click', function() {
            const tag = this.getAttribute('data-tag');
            
            if (selectedTags.has(tag)) {
              selectedTags.delete(tag);
              this.classList.remove('active');
            } else {
              selectedTags.add(tag);
              this.classList.add('active');
            }
            
            updateActiveFilters();
            filterPosts();
          });
        }
      });
    }

    if (clearButton) {
      clearButton.addEventListener('click', function() {
        selectedTags.clear();
        if (tagButtons && tagButtons.length > 0) {
          tagButtons.forEach(function(btn) {
            btn.classList.remove('active');
          });
        }
        updateActiveFilters();
        filterPosts();
      });
    }
  }
  
  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>

<style>
.tag-filter-btn.active {
  background-color: #2e7d32;
  border-color: #2e7d32;
}
</style>
